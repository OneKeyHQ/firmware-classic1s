// This file is automatically generated from ethereum_tokens_onekey.c.mako
// DO NOT EDIT

#include <string.h>
#include "ethereum_tokens_onekey.h"

const TokenType tokens[TOKENS_COUNT] = {
% for t in sorted(erc20, key=lambda t: t.chain_id):
	{${"{:>2}".format(t.chain_id)}, ${c_str(t.address_bytes)}, " ${ascii(t.symbol)}", ${t.decimals}}, // ${t.chain} / ${t.name}
% endfor
	{9798, "\xE5\x2a\x73\x68\x28\xc7\x82\xC2\xa4\xA3\x45\xbB\xE8\x05\x2a\xed\x01\x0f\xc8\x2D", " HLT", 2}, // DTC / HLT
	{9798, "\x8E\x79\x85\x0C\x50\xE5\x25\xeB\x6B\xa6\x3e\x60\x1E\x7b\x41\x88\x8A\x1c\x91\x02", " BV", 2}, // DTC / BV
	{9798, "\x36\xE6\x50\x4c\x96\x8f\x5C\x2A\x31\x0B\x6A\xF7\xB9\x7B\xC2\x2c\xdd\x34\x02\xcc", " dUSDT", 6}, // DTC / dUSDT
	{9798, "\xE8\x95\xc5\x77\xD7\x47\xbB\x5d\xbB\xc1\xF0\x6c\xb4\x4d\x60\x67\x68\x0b\xE4\xbe", " dBTC", 8}, // DTC / dBTC
	{9798, "\x8B\x71\x60\xC1\xE9\xfD\xb6\x89\xA0\x60\xFF\x09\x19\xE8\x49\x15\xB0\xdF\xa0\x4a", " dETH", 18}, // DTC / dETH
	{9798, "\x74\x5C\x11\xFb\x47\x83\xBd\x00\xA8\x8a\x0B\x99\x42\x02\x62\xf4\x09\xFA\x8B\xb8", " DOS", 2}, // DTC / DOS
	{9798, "\x89\x9f\x0B\x9d\x67\xDD\x1B\x83\x3f\xda\xa9\x0c\x8b\x09\xea\x61\x6d\x0e\x9E\x98", " CNV", 2}, // DTC / CNV
	{9798, "\xb8\x8a\xd7\x67\xB4\x16\x19\x7e\x62\x93\x9d\xEc\x20\x74\x31\xb5\x61\xA9\x38\x3B", " FEC", 4}, // DTC / FEC
	{9798, "\x6d\x88\x5b\x0B\x37\xC6\x2B\xe0\xc7\x2E\xcd\x6a\x61\xAf\x2b\xfF\xf6\x81\x41\x9e", " STC08375", 0}, // DTC / STC08375
};

static const TokenType _UnknownToken = { 0, "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff", " UNKN", 0 };
const TokenType *UnknownToken = &_UnknownToken;

const TokenType *tokenByChainAddress(uint64_t chain_id, const uint8_t *address)
{
	if (!address) return 0;
	for (int i = 0; i < TOKENS_COUNT; i++) {
		if (chain_id == tokens[i].chain_id && memcmp(address, tokens[i].address, 20) == 0) {
			return &(tokens[i]);
		}
	}
	return UnknownToken;
}
